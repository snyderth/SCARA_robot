// megafunction wizard: %ALTFP_INV%
// GENERATION: STANDARD
// VERSION: WM1.0
// MODULE: ALTFP_INV 

// ============================================================
// File Name: Inverter.v
// Megafunction Name(s):
// 			ALTFP_INV
//
// Simulation Library Files(s):
// 			lpm
// ============================================================
// ************************************************************
// THIS IS A WIZARD-GENERATED FILE. DO NOT EDIT THIS FILE!
//
// 18.1.0 Build 625 09/12/2018 SJ Lite Edition
// ************************************************************


//Copyright (C) 2018  Intel Corporation. All rights reserved.
//Your use of Intel Corporation's design tools, logic functions 
//and other software and tools, and its AMPP partner logic 
//functions, and any output files from any of the foregoing 
//(including device programming or simulation files), and any 
//associated documentation or information are expressly subject 
//to the terms and conditions of the Intel Program License 
//Subscription Agreement, the Intel Quartus Prime License Agreement,
//the Intel FPGA IP License Agreement, or other applicable license
//agreement, including, without limitation, that your use is for
//the sole purpose of programming logic devices manufactured by
//Intel and sold by Intel or its authorized distributors.  Please
//refer to the applicable agreement for further details.


//altfp_inv CBX_AUTO_BLACKBOX="ALL" DEVICE_FAMILY="Cyclone V" PIPELINE=27 ROUNDING="TO_NEAREST" WIDTH_EXP=11 WIDTH_MAN=52 clk_en clock data division_by_zero nan result underflow zero
//VERSION_BEGIN 18.1 cbx_altfp_inv 2018:09:12:13:04:24:SJ cbx_cycloneii 2018:09:12:13:04:24:SJ cbx_lpm_add_sub 2018:09:12:13:04:24:SJ cbx_lpm_compare 2018:09:12:13:04:24:SJ cbx_lpm_mult 2018:09:12:13:04:24:SJ cbx_lpm_mux 2018:09:12:13:04:24:SJ cbx_mgl 2018:09:12:13:10:36:SJ cbx_nadder 2018:09:12:13:04:24:SJ cbx_padd 2018:09:12:13:04:24:SJ cbx_stratix 2018:09:12:13:04:24:SJ cbx_stratixii 2018:09:12:13:04:24:SJ cbx_util_mgl 2018:09:12:13:04:24:SJ  VERSION_END
// synthesis VERILOG_INPUT_VERSION VERILOG_2001
// altera message_off 10463



//altfp_inv_and_or CBX_AUTO_BLACKBOX="ALL" DEVICE_FAMILY="Cyclone V" LUT_INPUT_COUNT=6 OPERATION="OR" PIPELINE=3 WIDTH=52 aclr clken clock data result
//VERSION_BEGIN 18.1 cbx_altfp_inv 2018:09:12:13:04:24:SJ cbx_cycloneii 2018:09:12:13:04:24:SJ cbx_lpm_add_sub 2018:09:12:13:04:24:SJ cbx_lpm_compare 2018:09:12:13:04:24:SJ cbx_lpm_mult 2018:09:12:13:04:24:SJ cbx_lpm_mux 2018:09:12:13:04:24:SJ cbx_mgl 2018:09:12:13:10:36:SJ cbx_nadder 2018:09:12:13:04:24:SJ cbx_padd 2018:09:12:13:04:24:SJ cbx_stratix 2018:09:12:13:04:24:SJ cbx_stratixii 2018:09:12:13:04:24:SJ cbx_util_mgl 2018:09:12:13:04:24:SJ  VERSION_END

//synthesis_resources = reg 12 
//synopsys translate_off
`timescale 1 ps / 1 ps
//synopsys translate_on
module  Inverter_altfp_inv_and_or_ekd
	( 
	aclr,
	clken,
	clock,
	data,
	result) ;
	input   aclr;
	input   clken;
	input   clock;
	input   [51:0]  data;
	output   result;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_off
`endif
	tri0   aclr;
	tri1   clken;
	tri0   clock;
	tri0   [51:0]  data;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_on
`endif

	reg	[8:0]	connection_dffe0;
	reg	[1:0]	connection_dffe1;
	reg	[0:0]	connection_dffe2;
	wire  [51:0]  connection_r0_w;
	wire  [8:0]  connection_r1_w;
	wire  [1:0]  connection_r2_w;
	wire  [0:0]  connection_r3_w;
	wire  [51:0]  operation_r1_w;
	wire  [8:0]  operation_r2_w;
	wire  [1:0]  operation_r3_w;

	// synopsys translate_off
	initial
		connection_dffe0 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) connection_dffe0 <= 9'b0;
		else if  (clken == 1'b1)   connection_dffe0 <= {operation_r1_w[51], operation_r1_w[47], operation_r1_w[41], operation_r1_w[35], operation_r1_w[29], operation_r1_w[23], operation_r1_w[17], operation_r1_w[11], operation_r1_w[5]};
	// synopsys translate_off
	initial
		connection_dffe1 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) connection_dffe1 <= 2'b0;
		else if  (clken == 1'b1)   connection_dffe1 <= {operation_r2_w[8], operation_r2_w[5]};
	// synopsys translate_off
	initial
		connection_dffe2 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) connection_dffe2 <= 1'b0;
		else if  (clken == 1'b1)   connection_dffe2 <= {operation_r3_w[1]};
	assign
		connection_r0_w = data,
		connection_r1_w = connection_dffe0,
		connection_r2_w = connection_dffe1,
		connection_r3_w = connection_dffe2,
		operation_r1_w = {(operation_r1_w[50] | connection_r0_w[51]), (operation_r1_w[49] | connection_r0_w[50]), (operation_r1_w[48] | connection_r0_w[49]), connection_r0_w[48], (operation_r1_w[46] | connection_r0_w[47]), (operation_r1_w[45] | connection_r0_w[46]), (operation_r1_w[44] | connection_r0_w[45]), (operation_r1_w[43] | connection_r0_w[44]), (operation_r1_w[42] | connection_r0_w[43]), connection_r0_w[42], (operation_r1_w[40] | connection_r0_w[41]), (operation_r1_w[39] | connection_r0_w[40]), (operation_r1_w[38] | connection_r0_w[39]), (operation_r1_w[37] | connection_r0_w[38]), (operation_r1_w[36] | connection_r0_w[37]), connection_r0_w[36], (operation_r1_w[34] | connection_r0_w[35]), (operation_r1_w[33] | connection_r0_w[34]), (operation_r1_w[32] | connection_r0_w[33]), (operation_r1_w[31] | connection_r0_w[32]), (operation_r1_w[30] | connection_r0_w[31]), connection_r0_w[30], (operation_r1_w[28] | connection_r0_w[29]), (operation_r1_w[27] | connection_r0_w[28]), (operation_r1_w[26] | connection_r0_w[27]), (operation_r1_w[25] | connection_r0_w[26]), (operation_r1_w[24] | connection_r0_w[25]), connection_r0_w[24], (operation_r1_w[22] | connection_r0_w[23]), (operation_r1_w[21] | connection_r0_w[22]), (operation_r1_w[20] | connection_r0_w[21]), (operation_r1_w[19] | connection_r0_w[20]), (operation_r1_w[18] | connection_r0_w[19]), connection_r0_w[18], (operation_r1_w[16] | connection_r0_w[17]), (operation_r1_w[15] | connection_r0_w[16]), (operation_r1_w[14] | connection_r0_w[15]), (operation_r1_w[13] | connection_r0_w[14]), (operation_r1_w[12] | connection_r0_w[13]), connection_r0_w[12], (operation_r1_w[10] | connection_r0_w[11]), (operation_r1_w[9] | connection_r0_w[10]), (operation_r1_w[8] | connection_r0_w[9]), (operation_r1_w[7] | connection_r0_w[8]), (operation_r1_w[6] | connection_r0_w[7]), connection_r0_w[6], (operation_r1_w[4] | connection_r0_w[5]), (operation_r1_w[3] | connection_r0_w[4]), (operation_r1_w[2] | connection_r0_w[3]), (operation_r1_w[1] | connection_r0_w[2]), (operation_r1_w[0] | connection_r0_w[1]
), connection_r0_w[0]},
		operation_r2_w = {(operation_r2_w[7] | connection_r1_w[8]), (operation_r2_w[6] | connection_r1_w[7]), connection_r1_w[6], (operation_r2_w[4] | connection_r1_w[5]), (operation_r2_w[3] | connection_r1_w[4]), (operation_r2_w[2] | connection_r1_w[3]), (operation_r2_w[1] | connection_r1_w[2]), (operation_r2_w[0] | connection_r1_w[1]), connection_r1_w[0]},
		operation_r3_w = {(operation_r3_w[0] | connection_r2_w[1]), connection_r2_w[0]},
		result = connection_r3_w[0];
endmodule //Inverter_altfp_inv_and_or_ekd


//altfp_inv_and_or CBX_AUTO_BLACKBOX="ALL" DEVICE_FAMILY="Cyclone V" LUT_INPUT_COUNT=6 OPERATION="AND" PIPELINE=3 WIDTH=52 aclr clken clock data result
//VERSION_BEGIN 18.1 cbx_altfp_inv 2018:09:12:13:04:24:SJ cbx_cycloneii 2018:09:12:13:04:24:SJ cbx_lpm_add_sub 2018:09:12:13:04:24:SJ cbx_lpm_compare 2018:09:12:13:04:24:SJ cbx_lpm_mult 2018:09:12:13:04:24:SJ cbx_lpm_mux 2018:09:12:13:04:24:SJ cbx_mgl 2018:09:12:13:10:36:SJ cbx_nadder 2018:09:12:13:04:24:SJ cbx_padd 2018:09:12:13:04:24:SJ cbx_stratix 2018:09:12:13:04:24:SJ cbx_stratixii 2018:09:12:13:04:24:SJ cbx_util_mgl 2018:09:12:13:04:24:SJ  VERSION_END

//synthesis_resources = reg 12 
//synopsys translate_off
`timescale 1 ps / 1 ps
//synopsys translate_on
module  Inverter_altfp_inv_and_or_0nd
	( 
	aclr,
	clken,
	clock,
	data,
	result) ;
	input   aclr;
	input   clken;
	input   clock;
	input   [51:0]  data;
	output   result;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_off
`endif
	tri0   aclr;
	tri1   clken;
	tri0   clock;
	tri0   [51:0]  data;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_on
`endif

	reg	[8:0]	connection_dffe0;
	reg	[1:0]	connection_dffe1;
	reg	[0:0]	connection_dffe2;
	wire  [51:0]  connection_r0_w;
	wire  [8:0]  connection_r1_w;
	wire  [1:0]  connection_r2_w;
	wire  [0:0]  connection_r3_w;
	wire  [51:0]  operation_r1_w;
	wire  [8:0]  operation_r2_w;
	wire  [1:0]  operation_r3_w;

	// synopsys translate_off
	initial
		connection_dffe0 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) connection_dffe0 <= 9'b0;
		else if  (clken == 1'b1)   connection_dffe0 <= {operation_r1_w[51], operation_r1_w[47], operation_r1_w[41], operation_r1_w[35], operation_r1_w[29], operation_r1_w[23], operation_r1_w[17], operation_r1_w[11], operation_r1_w[5]};
	// synopsys translate_off
	initial
		connection_dffe1 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) connection_dffe1 <= 2'b0;
		else if  (clken == 1'b1)   connection_dffe1 <= {operation_r2_w[8], operation_r2_w[5]};
	// synopsys translate_off
	initial
		connection_dffe2 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) connection_dffe2 <= 1'b0;
		else if  (clken == 1'b1)   connection_dffe2 <= {operation_r3_w[1]};
	assign
		connection_r0_w = data,
		connection_r1_w = connection_dffe0,
		connection_r2_w = connection_dffe1,
		connection_r3_w = connection_dffe2,
		operation_r1_w = {(operation_r1_w[50] & connection_r0_w[51]), (operation_r1_w[49] & connection_r0_w[50]), (operation_r1_w[48] & connection_r0_w[49]), connection_r0_w[48], (operation_r1_w[46] & connection_r0_w[47]), (operation_r1_w[45] & connection_r0_w[46]), (operation_r1_w[44] & connection_r0_w[45]), (operation_r1_w[43] & connection_r0_w[44]), (operation_r1_w[42] & connection_r0_w[43]), connection_r0_w[42], (operation_r1_w[40] & connection_r0_w[41]), (operation_r1_w[39] & connection_r0_w[40]), (operation_r1_w[38] & connection_r0_w[39]), (operation_r1_w[37] & connection_r0_w[38]), (operation_r1_w[36] & connection_r0_w[37]), connection_r0_w[36], (operation_r1_w[34] & connection_r0_w[35]), (operation_r1_w[33] & connection_r0_w[34]), (operation_r1_w[32] & connection_r0_w[33]), (operation_r1_w[31] & connection_r0_w[32]), (operation_r1_w[30] & connection_r0_w[31]), connection_r0_w[30], (operation_r1_w[28] & connection_r0_w[29]), (operation_r1_w[27] & connection_r0_w[28]), (operation_r1_w[26] & connection_r0_w[27]), (operation_r1_w[25] & connection_r0_w[26]), (operation_r1_w[24] & connection_r0_w[25]), connection_r0_w[24], (operation_r1_w[22] & connection_r0_w[23]), (operation_r1_w[21] & connection_r0_w[22]), (operation_r1_w[20] & connection_r0_w[21]), (operation_r1_w[19] & connection_r0_w[20]), (operation_r1_w[18] & connection_r0_w[19]), connection_r0_w[18], (operation_r1_w[16] & connection_r0_w[17]), (operation_r1_w[15] & connection_r0_w[16]), (operation_r1_w[14] & connection_r0_w[15]), (operation_r1_w[13] & connection_r0_w[14]), (operation_r1_w[12] & connection_r0_w[13]), connection_r0_w[12], (operation_r1_w[10] & connection_r0_w[11]), (operation_r1_w[9] & connection_r0_w[10]), (operation_r1_w[8] & connection_r0_w[9]), (operation_r1_w[7] & connection_r0_w[8]), (operation_r1_w[6] & connection_r0_w[7]), connection_r0_w[6], (operation_r1_w[4] & connection_r0_w[5]), (operation_r1_w[3] & connection_r0_w[4]), (operation_r1_w[2] & connection_r0_w[3]), (operation_r1_w[1] & connection_r0_w[2]), (operation_r1_w[0] & connection_r0_w[1]
), connection_r0_w[0]},
		operation_r2_w = {(operation_r2_w[7] & connection_r1_w[8]), (operation_r2_w[6] & connection_r1_w[7]), connection_r1_w[6], (operation_r2_w[4] & connection_r1_w[5]), (operation_r2_w[3] & connection_r1_w[4]), (operation_r2_w[2] & connection_r1_w[3]), (operation_r2_w[1] & connection_r1_w[2]), (operation_r2_w[0] & connection_r1_w[1]), connection_r1_w[0]},
		operation_r3_w = {(operation_r3_w[0] & connection_r2_w[1]), connection_r2_w[0]},
		result = connection_r3_w[0];
endmodule //Inverter_altfp_inv_and_or_0nd


//altfp_inv_and_or CBX_AUTO_BLACKBOX="ALL" DEVICE_FAMILY="Cyclone V" LUT_INPUT_COUNT=6 OPERATION="OR" PIPELINE=3 WIDTH=11 aclr clken clock data result
//VERSION_BEGIN 18.1 cbx_altfp_inv 2018:09:12:13:04:24:SJ cbx_cycloneii 2018:09:12:13:04:24:SJ cbx_lpm_add_sub 2018:09:12:13:04:24:SJ cbx_lpm_compare 2018:09:12:13:04:24:SJ cbx_lpm_mult 2018:09:12:13:04:24:SJ cbx_lpm_mux 2018:09:12:13:04:24:SJ cbx_mgl 2018:09:12:13:10:36:SJ cbx_nadder 2018:09:12:13:04:24:SJ cbx_padd 2018:09:12:13:04:24:SJ cbx_stratix 2018:09:12:13:04:24:SJ cbx_stratixii 2018:09:12:13:04:24:SJ cbx_util_mgl 2018:09:12:13:04:24:SJ  VERSION_END

//synthesis_resources = reg 4 
//synopsys translate_off
`timescale 1 ps / 1 ps
//synopsys translate_on
module  Inverter_altfp_inv_and_or_9kd
	( 
	aclr,
	clken,
	clock,
	data,
	result) ;
	input   aclr;
	input   clken;
	input   clock;
	input   [10:0]  data;
	output   result;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_off
`endif
	tri0   aclr;
	tri1   clken;
	tri0   clock;
	tri0   [10:0]  data;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_on
`endif

	reg	[1:0]	connection_dffe0;
	reg	[0:0]	connection_dffe1;
	reg	connection_dffe2;
	wire  [10:0]  connection_r0_w;
	wire  [1:0]  connection_r1_w;
	wire  [0:0]  connection_r2_w;
	wire  [10:0]  operation_r1_w;
	wire  [1:0]  operation_r2_w;

	// synopsys translate_off
	initial
		connection_dffe0 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) connection_dffe0 <= 2'b0;
		else if  (clken == 1'b1)   connection_dffe0 <= {operation_r1_w[10], operation_r1_w[5]};
	// synopsys translate_off
	initial
		connection_dffe1 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) connection_dffe1 <= 1'b0;
		else if  (clken == 1'b1)   connection_dffe1 <= {operation_r2_w[1]};
	// synopsys translate_off
	initial
		connection_dffe2 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) connection_dffe2 <= 1'b0;
		else if  (clken == 1'b1)   connection_dffe2 <= connection_r2_w[0];
	assign
		connection_r0_w = data,
		connection_r1_w = connection_dffe0,
		connection_r2_w = connection_dffe1,
		operation_r1_w = {(operation_r1_w[9] | connection_r0_w[10]), (operation_r1_w[8] | connection_r0_w[9]), (operation_r1_w[7] | connection_r0_w[8]), (operation_r1_w[6] | connection_r0_w[7]), connection_r0_w[6], (operation_r1_w[4] | connection_r0_w[5]), (operation_r1_w[3] | connection_r0_w[4]), (operation_r1_w[2] | connection_r0_w[3]), (operation_r1_w[1] | connection_r0_w[2]), (operation_r1_w[0] | connection_r0_w[1]), connection_r0_w[0]},
		operation_r2_w = {(operation_r2_w[0] | connection_r1_w[1]), connection_r1_w[0]},
		result = connection_dffe2;
endmodule //Inverter_altfp_inv_and_or_9kd


//altfp_inv_and_or CBX_AUTO_BLACKBOX="ALL" DEVICE_FAMILY="Cyclone V" LUT_INPUT_COUNT=6 OPERATION="AND" PIPELINE=3 WIDTH=11 aclr clken clock data result
//VERSION_BEGIN 18.1 cbx_altfp_inv 2018:09:12:13:04:24:SJ cbx_cycloneii 2018:09:12:13:04:24:SJ cbx_lpm_add_sub 2018:09:12:13:04:24:SJ cbx_lpm_compare 2018:09:12:13:04:24:SJ cbx_lpm_mult 2018:09:12:13:04:24:SJ cbx_lpm_mux 2018:09:12:13:04:24:SJ cbx_mgl 2018:09:12:13:10:36:SJ cbx_nadder 2018:09:12:13:04:24:SJ cbx_padd 2018:09:12:13:04:24:SJ cbx_stratix 2018:09:12:13:04:24:SJ cbx_stratixii 2018:09:12:13:04:24:SJ cbx_util_mgl 2018:09:12:13:04:24:SJ  VERSION_END

//synthesis_resources = reg 4 
//synopsys translate_off
`timescale 1 ps / 1 ps
//synopsys translate_on
module  Inverter_altfp_inv_and_or_rmd
	( 
	aclr,
	clken,
	clock,
	data,
	result) ;
	input   aclr;
	input   clken;
	input   clock;
	input   [10:0]  data;
	output   result;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_off
`endif
	tri0   aclr;
	tri1   clken;
	tri0   clock;
	tri0   [10:0]  data;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_on
`endif

	reg	[1:0]	connection_dffe0;
	reg	[0:0]	connection_dffe1;
	reg	connection_dffe2;
	wire  [10:0]  connection_r0_w;
	wire  [1:0]  connection_r1_w;
	wire  [0:0]  connection_r2_w;
	wire  [10:0]  operation_r1_w;
	wire  [1:0]  operation_r2_w;

	// synopsys translate_off
	initial
		connection_dffe0 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) connection_dffe0 <= 2'b0;
		else if  (clken == 1'b1)   connection_dffe0 <= {operation_r1_w[10], operation_r1_w[5]};
	// synopsys translate_off
	initial
		connection_dffe1 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) connection_dffe1 <= 1'b0;
		else if  (clken == 1'b1)   connection_dffe1 <= {operation_r2_w[1]};
	// synopsys translate_off
	initial
		connection_dffe2 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) connection_dffe2 <= 1'b0;
		else if  (clken == 1'b1)   connection_dffe2 <= connection_r2_w[0];
	assign
		connection_r0_w = data,
		connection_r1_w = connection_dffe0,
		connection_r2_w = connection_dffe1,
		operation_r1_w = {(operation_r1_w[9] & connection_r0_w[10]), (operation_r1_w[8] & connection_r0_w[9]), (operation_r1_w[7] & connection_r0_w[8]), (operation_r1_w[6] & connection_r0_w[7]), connection_r0_w[6], (operation_r1_w[4] & connection_r0_w[5]), (operation_r1_w[3] & connection_r0_w[4]), (operation_r1_w[2] & connection_r0_w[3]), (operation_r1_w[1] & connection_r0_w[2]), (operation_r1_w[0] & connection_r0_w[1]), connection_r0_w[0]},
		operation_r2_w = {(operation_r2_w[0] & connection_r1_w[1]), connection_r1_w[0]},
		result = connection_dffe2;
endmodule //Inverter_altfp_inv_and_or_rmd


//altfp_inv_csa CARRY_SELECT="YES" CBX_AUTO_BLACKBOX="ALL" DEVICE_FAMILY="Cyclone V" DIRECTION="SUB" PIPELINE=1 REGISTER_INPUT="NO" REPRESENTATION="UNSIGNED" WIDTH=26 aclr clken clock dataa datab result
//VERSION_BEGIN 18.1 cbx_altfp_inv 2018:09:12:13:04:24:SJ cbx_cycloneii 2018:09:12:13:04:24:SJ cbx_lpm_add_sub 2018:09:12:13:04:24:SJ cbx_lpm_compare 2018:09:12:13:04:24:SJ cbx_lpm_mult 2018:09:12:13:04:24:SJ cbx_lpm_mux 2018:09:12:13:04:24:SJ cbx_mgl 2018:09:12:13:10:36:SJ cbx_nadder 2018:09:12:13:04:24:SJ cbx_padd 2018:09:12:13:04:24:SJ cbx_stratix 2018:09:12:13:04:24:SJ cbx_stratixii 2018:09:12:13:04:24:SJ cbx_util_mgl 2018:09:12:13:04:24:SJ  VERSION_END

//synthesis_resources = lpm_add_sub 3 
//synopsys translate_off
`timescale 1 ps / 1 ps
//synopsys translate_on
module  Inverter_altfp_inv_csa_tbi
	( 
	aclr,
	clken,
	clock,
	dataa,
	datab,
	result) ;
	input   aclr;
	input   clken;
	input   clock;
	input   [25:0]  dataa;
	input   [25:0]  datab;
	output   [25:0]  result;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_off
`endif
	tri0   aclr;
	tri1   clken;
	tri0   clock;
	tri0   [25:0]  dataa;
	tri0   [25:0]  datab;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_on
`endif

	wire  wire_csa_lower_cout;
	wire  [12:0]   wire_csa_lower_result;
	wire  [12:0]   wire_csa_upper0_result;
	wire  [12:0]   wire_csa_upper1_result;
	wire  [25:0]  dataa_w;
	wire  [25:0]  datab_w;
	wire  [25:0]  result_w;

	lpm_add_sub   csa_lower
	( 
	.aclr(aclr),
	.clken(clken),
	.clock(clock),
	.cout(wire_csa_lower_cout),
	.dataa(dataa_w[12:0]),
	.datab(datab_w[12:0]),
	.overflow(),
	.result(wire_csa_lower_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.add_sub(1'b1),
	.cin()
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		csa_lower.lpm_direction = "SUB",
		csa_lower.lpm_pipeline = 1,
		csa_lower.lpm_representation = "UNSIGNED",
		csa_lower.lpm_width = 13,
		csa_lower.lpm_type = "lpm_add_sub";
	lpm_add_sub   csa_upper0
	( 
	.aclr(aclr),
	.cin(1'b0),
	.clken(clken),
	.clock(clock),
	.cout(),
	.dataa(dataa_w[25:13]),
	.datab(datab_w[25:13]),
	.overflow(),
	.result(wire_csa_upper0_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.add_sub(1'b1)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		csa_upper0.lpm_direction = "SUB",
		csa_upper0.lpm_pipeline = 1,
		csa_upper0.lpm_representation = "UNSIGNED",
		csa_upper0.lpm_width = 13,
		csa_upper0.lpm_type = "lpm_add_sub";
	lpm_add_sub   csa_upper1
	( 
	.aclr(aclr),
	.cin(1'b1),
	.clken(clken),
	.clock(clock),
	.cout(),
	.dataa(dataa_w[25:13]),
	.datab(datab_w[25:13]),
	.overflow(),
	.result(wire_csa_upper1_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.add_sub(1'b1)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		csa_upper1.lpm_direction = "SUB",
		csa_upper1.lpm_pipeline = 1,
		csa_upper1.lpm_representation = "UNSIGNED",
		csa_upper1.lpm_width = 13,
		csa_upper1.lpm_type = "lpm_add_sub";
	assign
		dataa_w = dataa,
		datab_w = datab,
		result = result_w,
		result_w = {(({13{(~ wire_csa_lower_cout)}} & wire_csa_upper0_result) | ({13{wire_csa_lower_cout}} & wire_csa_upper1_result)), wire_csa_lower_result};
endmodule //Inverter_altfp_inv_csa_tbi


//altfp_inv_csa CARRY_SELECT="YES" CBX_AUTO_BLACKBOX="ALL" DEVICE_FAMILY="Cyclone V" DIRECTION="SUB" PIPELINE=1 REGISTER_INPUT="NO" REPRESENTATION="UNSIGNED" WIDTH=41 aclr clken clock dataa datab result
//VERSION_BEGIN 18.1 cbx_altfp_inv 2018:09:12:13:04:24:SJ cbx_cycloneii 2018:09:12:13:04:24:SJ cbx_lpm_add_sub 2018:09:12:13:04:24:SJ cbx_lpm_compare 2018:09:12:13:04:24:SJ cbx_lpm_mult 2018:09:12:13:04:24:SJ cbx_lpm_mux 2018:09:12:13:04:24:SJ cbx_mgl 2018:09:12:13:10:36:SJ cbx_nadder 2018:09:12:13:04:24:SJ cbx_padd 2018:09:12:13:04:24:SJ cbx_stratix 2018:09:12:13:04:24:SJ cbx_stratixii 2018:09:12:13:04:24:SJ cbx_util_mgl 2018:09:12:13:04:24:SJ  VERSION_END

//synthesis_resources = lpm_add_sub 3 
//synopsys translate_off
`timescale 1 ps / 1 ps
//synopsys translate_on
module  Inverter_altfp_inv_csa_qbi
	( 
	aclr,
	clken,
	clock,
	dataa,
	datab,
	result) ;
	input   aclr;
	input   clken;
	input   clock;
	input   [40:0]  dataa;
	input   [40:0]  datab;
	output   [40:0]  result;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_off
`endif
	tri0   aclr;
	tri1   clken;
	tri0   clock;
	tri0   [40:0]  dataa;
	tri0   [40:0]  datab;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_on
`endif

	wire  wire_csa_lower_cout;
	wire  [20:0]   wire_csa_lower_result;
	wire  [19:0]   wire_csa_upper0_result;
	wire  [19:0]   wire_csa_upper1_result;
	wire  [40:0]  dataa_w;
	wire  [40:0]  datab_w;
	wire  [40:0]  result_w;

	lpm_add_sub   csa_lower
	( 
	.aclr(aclr),
	.clken(clken),
	.clock(clock),
	.cout(wire_csa_lower_cout),
	.dataa(dataa_w[20:0]),
	.datab(datab_w[20:0]),
	.overflow(),
	.result(wire_csa_lower_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.add_sub(1'b1),
	.cin()
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		csa_lower.lpm_direction = "SUB",
		csa_lower.lpm_pipeline = 1,
		csa_lower.lpm_representation = "UNSIGNED",
		csa_lower.lpm_width = 21,
		csa_lower.lpm_type = "lpm_add_sub";
	lpm_add_sub   csa_upper0
	( 
	.aclr(aclr),
	.cin(1'b0),
	.clken(clken),
	.clock(clock),
	.cout(),
	.dataa(dataa_w[40:21]),
	.datab(datab_w[40:21]),
	.overflow(),
	.result(wire_csa_upper0_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.add_sub(1'b1)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		csa_upper0.lpm_direction = "SUB",
		csa_upper0.lpm_pipeline = 1,
		csa_upper0.lpm_representation = "UNSIGNED",
		csa_upper0.lpm_width = 20,
		csa_upper0.lpm_type = "lpm_add_sub";
	lpm_add_sub   csa_upper1
	( 
	.aclr(aclr),
	.cin(1'b1),
	.clken(clken),
	.clock(clock),
	.cout(),
	.dataa(dataa_w[40:21]),
	.datab(datab_w[40:21]),
	.overflow(),
	.result(wire_csa_upper1_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.add_sub(1'b1)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		csa_upper1.lpm_direction = "SUB",
		csa_upper1.lpm_pipeline = 1,
		csa_upper1.lpm_representation = "UNSIGNED",
		csa_upper1.lpm_width = 20,
		csa_upper1.lpm_type = "lpm_add_sub";
	assign
		dataa_w = dataa,
		datab_w = datab,
		result = result_w,
		result_w = {(({20{(~ wire_csa_lower_cout)}} & wire_csa_upper0_result) | ({20{wire_csa_lower_cout}} & wire_csa_upper1_result)), wire_csa_lower_result};
endmodule //Inverter_altfp_inv_csa_qbi


//altfp_inv_csa CARRY_SELECT="YES" CBX_AUTO_BLACKBOX="ALL" DEVICE_FAMILY="Cyclone V" DIRECTION="SUB" PIPELINE=1 REGISTER_INPUT="NO" REPRESENTATION="UNSIGNED" WIDTH=55 aclr clken clock dataa datab result
//VERSION_BEGIN 18.1 cbx_altfp_inv 2018:09:12:13:04:24:SJ cbx_cycloneii 2018:09:12:13:04:24:SJ cbx_lpm_add_sub 2018:09:12:13:04:24:SJ cbx_lpm_compare 2018:09:12:13:04:24:SJ cbx_lpm_mult 2018:09:12:13:04:24:SJ cbx_lpm_mux 2018:09:12:13:04:24:SJ cbx_mgl 2018:09:12:13:10:36:SJ cbx_nadder 2018:09:12:13:04:24:SJ cbx_padd 2018:09:12:13:04:24:SJ cbx_stratix 2018:09:12:13:04:24:SJ cbx_stratixii 2018:09:12:13:04:24:SJ cbx_util_mgl 2018:09:12:13:04:24:SJ  VERSION_END

//synthesis_resources = lpm_add_sub 3 
//synopsys translate_off
`timescale 1 ps / 1 ps
//synopsys translate_on
module  Inverter_altfp_inv_csa_vbi
	( 
	aclr,
	clken,
	clock,
	dataa,
	datab,
	result) ;
	input   aclr;
	input   clken;
	input   clock;
	input   [54:0]  dataa;
	input   [54:0]  datab;
	output   [54:0]  result;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_off
`endif
	tri0   aclr;
	tri1   clken;
	tri0   clock;
	tri0   [54:0]  dataa;
	tri0   [54:0]  datab;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_on
`endif

	wire  wire_csa_lower_cout;
	wire  [27:0]   wire_csa_lower_result;
	wire  [26:0]   wire_csa_upper0_result;
	wire  [26:0]   wire_csa_upper1_result;
	wire  [54:0]  dataa_w;
	wire  [54:0]  datab_w;
	wire  [54:0]  result_w;

	lpm_add_sub   csa_lower
	( 
	.aclr(aclr),
	.clken(clken),
	.clock(clock),
	.cout(wire_csa_lower_cout),
	.dataa(dataa_w[27:0]),
	.datab(datab_w[27:0]),
	.overflow(),
	.result(wire_csa_lower_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.add_sub(1'b1),
	.cin()
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		csa_lower.lpm_direction = "SUB",
		csa_lower.lpm_pipeline = 1,
		csa_lower.lpm_representation = "UNSIGNED",
		csa_lower.lpm_width = 28,
		csa_lower.lpm_type = "lpm_add_sub";
	lpm_add_sub   csa_upper0
	( 
	.aclr(aclr),
	.cin(1'b0),
	.clken(clken),
	.clock(clock),
	.cout(),
	.dataa(dataa_w[54:28]),
	.datab(datab_w[54:28]),
	.overflow(),
	.result(wire_csa_upper0_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.add_sub(1'b1)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		csa_upper0.lpm_direction = "SUB",
		csa_upper0.lpm_pipeline = 1,
		csa_upper0.lpm_representation = "UNSIGNED",
		csa_upper0.lpm_width = 27,
		csa_upper0.lpm_type = "lpm_add_sub";
	lpm_add_sub   csa_upper1
	( 
	.aclr(aclr),
	.cin(1'b1),
	.clken(clken),
	.clock(clock),
	.cout(),
	.dataa(dataa_w[54:28]),
	.datab(datab_w[54:28]),
	.overflow(),
	.result(wire_csa_upper1_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.add_sub(1'b1)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		csa_upper1.lpm_direction = "SUB",
		csa_upper1.lpm_pipeline = 1,
		csa_upper1.lpm_representation = "UNSIGNED",
		csa_upper1.lpm_width = 27,
		csa_upper1.lpm_type = "lpm_add_sub";
	assign
		dataa_w = dataa,
		datab_w = datab,
		result = result_w,
		result_w = {(({27{(~ wire_csa_lower_cout)}} & wire_csa_upper0_result) | ({27{wire_csa_lower_cout}} & wire_csa_upper1_result)), wire_csa_lower_result};
endmodule //Inverter_altfp_inv_csa_vbi


//altfp_inv_csa CARRY_SELECT="NO" CBX_AUTO_BLACKBOX="ALL" DEVICE_FAMILY="Cyclone V" DIRECTION="ADD" PIPELINE=1 REGISTER_INPUT="NO" REPRESENTATION="UNSIGNED" WIDTH=13 aclr clken clock dataa datab result
//VERSION_BEGIN 18.1 cbx_altfp_inv 2018:09:12:13:04:24:SJ cbx_cycloneii 2018:09:12:13:04:24:SJ cbx_lpm_add_sub 2018:09:12:13:04:24:SJ cbx_lpm_compare 2018:09:12:13:04:24:SJ cbx_lpm_mult 2018:09:12:13:04:24:SJ cbx_lpm_mux 2018:09:12:13:04:24:SJ cbx_mgl 2018:09:12:13:10:36:SJ cbx_nadder 2018:09:12:13:04:24:SJ cbx_padd 2018:09:12:13:04:24:SJ cbx_stratix 2018:09:12:13:04:24:SJ cbx_stratixii 2018:09:12:13:04:24:SJ cbx_util_mgl 2018:09:12:13:04:24:SJ  VERSION_END

//synthesis_resources = lpm_add_sub 1 
//synopsys translate_off
`timescale 1 ps / 1 ps
//synopsys translate_on
module  Inverter_altfp_inv_csa_47i
	( 
	aclr,
	clken,
	clock,
	dataa,
	datab,
	result) ;
	input   aclr;
	input   clken;
	input   clock;
	input   [12:0]  dataa;
	input   [12:0]  datab;
	output   [12:0]  result;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_off
`endif
	tri0   aclr;
	tri1   clken;
	tri0   clock;
	tri0   [12:0]  dataa;
	tri0   [12:0]  datab;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_on
`endif

	wire  [12:0]   wire_add_sub7_result;
	wire  [12:0]  dataa_w;
	wire  [12:0]  datab_w;
	wire  [12:0]  result_w;

	lpm_add_sub   add_sub7
	( 
	.aclr(aclr),
	.clken(clken),
	.clock(clock),
	.cout(),
	.dataa(dataa_w),
	.datab(datab_w),
	.overflow(),
	.result(wire_add_sub7_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.add_sub(1'b1),
	.cin()
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		add_sub7.lpm_direction = "ADD",
		add_sub7.lpm_pipeline = 1,
		add_sub7.lpm_representation = "UNSIGNED",
		add_sub7.lpm_width = 13,
		add_sub7.lpm_type = "lpm_add_sub";
	assign
		dataa_w = dataa,
		datab_w = datab,
		result = result_w,
		result_w = wire_add_sub7_result;
endmodule //Inverter_altfp_inv_csa_47i


//altfp_inv_csa CARRY_SELECT="NO" CBX_AUTO_BLACKBOX="ALL" DEVICE_FAMILY="Cyclone V" DIRECTION="SUB" PIPELINE=1 REGISTER_INPUT="NO" REPRESENTATION="UNSIGNED" WIDTH=13 aclr clken clock dataa datab result
//VERSION_BEGIN 18.1 cbx_altfp_inv 2018:09:12:13:04:24:SJ cbx_cycloneii 2018:09:12:13:04:24:SJ cbx_lpm_add_sub 2018:09:12:13:04:24:SJ cbx_lpm_compare 2018:09:12:13:04:24:SJ cbx_lpm_mult 2018:09:12:13:04:24:SJ cbx_lpm_mux 2018:09:12:13:04:24:SJ cbx_mgl 2018:09:12:13:10:36:SJ cbx_nadder 2018:09:12:13:04:24:SJ cbx_padd 2018:09:12:13:04:24:SJ cbx_stratix 2018:09:12:13:04:24:SJ cbx_stratixii 2018:09:12:13:04:24:SJ cbx_util_mgl 2018:09:12:13:04:24:SJ  VERSION_END

//synthesis_resources = lpm_add_sub 1 
//synopsys translate_off
`timescale 1 ps / 1 ps
//synopsys translate_on
module  Inverter_altfp_inv_csa_58i
	( 
	aclr,
	clken,
	clock,
	dataa,
	datab,
	result) ;
	input   aclr;
	input   clken;
	input   clock;
	input   [12:0]  dataa;
	input   [12:0]  datab;
	output   [12:0]  result;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_off
`endif
	tri0   aclr;
	tri1   clken;
	tri0   clock;
	tri0   [12:0]  dataa;
	tri0   [12:0]  datab;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_on
`endif

	wire  [12:0]   wire_add_sub8_result;
	wire  [12:0]  dataa_w;
	wire  [12:0]  datab_w;
	wire  [12:0]  result_w;

	lpm_add_sub   add_sub8
	( 
	.aclr(aclr),
	.clken(clken),
	.clock(clock),
	.cout(),
	.dataa(dataa_w),
	.datab(datab_w),
	.overflow(),
	.result(wire_add_sub8_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.add_sub(1'b1),
	.cin()
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		add_sub8.lpm_direction = "SUB",
		add_sub8.lpm_pipeline = 1,
		add_sub8.lpm_representation = "UNSIGNED",
		add_sub8.lpm_width = 13,
		add_sub8.lpm_type = "lpm_add_sub";
	assign
		dataa_w = dataa,
		datab_w = datab,
		result = result_w,
		result_w = wire_add_sub8_result;
endmodule //Inverter_altfp_inv_csa_58i

//synthesis_resources = lpm_add_sub 18 lpm_compare 1 lpm_mult 6 lpm_mux 1 reg 1911 
//synopsys translate_off
`timescale 1 ps / 1 ps
//synopsys translate_on
module  Inverter_altfp_inv_flg
	( 
	clk_en,
	clock,
	data,
	division_by_zero,
	nan,
	result,
	underflow,
	zero) ;
	input   clk_en;
	input   clock;
	input   [63:0]  data;
	output   division_by_zero;
	output   nan;
	output   [63:0]  result;
	output   underflow;
	output   zero;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_off
`endif
	tri1   clk_en;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_on
`endif

	wire  wire_altfp_inv_and_or2_result;
	wire  wire_altfp_inv_and_or3_result;
	wire  wire_altfp_inv_and_or4_result;
	wire  wire_altfp_inv_and_or5_result;
	wire  [25:0]   wire_diff_adder_0_result;
	wire  [40:0]   wire_diff_adder_1_result;
	wire  [54:0]   wire_diff_adder_2_result;
	wire  [12:0]   wire_slope_r1c1_add_result;
	wire  [12:0]   wire_slope_r1c2_add_result;
	wire  [12:0]   wire_slope_r1c3_add_result;
	wire  [12:0]   wire_slope_r2c1_add_result;
	wire  [12:0]   wire_slope_r2c2_add_result;
	wire  [12:0]   wire_slope_r3c1_add_result;
	reg	[12:0]	and_dffe_0;
	reg	[12:0]	and_dffe_1;
	reg	[12:0]	and_dffe_2;
	reg	[12:0]	and_dffe_3;
	reg	[12:0]	and_dffe_4;
	reg	[12:0]	and_dffe_5;
	reg	[2:0]	division_by_zero_dffe;
	reg	division_by_zero_output_dffe;
	reg	[10:0]	exp_dffe1_0;
	reg	[10:0]	exp_dffe1_1;
	reg	[10:0]	exp_dffe1_10;
	reg	[10:0]	exp_dffe1_11;
	reg	[10:0]	exp_dffe1_12;
	reg	[10:0]	exp_dffe1_13;
	reg	[10:0]	exp_dffe1_14;
	reg	[10:0]	exp_dffe1_15;
	reg	[10:0]	exp_dffe1_16;
	reg	[10:0]	exp_dffe1_17;
	reg	[10:0]	exp_dffe1_18;
	reg	[10:0]	exp_dffe1_19;
	reg	[10:0]	exp_dffe1_2;
	reg	[10:0]	exp_dffe1_20;
	reg	[10:0]	exp_dffe1_21;
	reg	[10:0]	exp_dffe1_3;
	reg	[10:0]	exp_dffe1_4;
	reg	[10:0]	exp_dffe1_5;
	reg	[10:0]	exp_dffe1_6;
	reg	[10:0]	exp_dffe1_7;
	reg	[10:0]	exp_dffe1_8;
	reg	[10:0]	exp_dffe1_9;
	reg	[10:0]	exp_dffe2_0;
	reg	[10:0]	exp_dffe2_1;
	reg	[10:0]	exp_dffe2_2;
	reg	[2:0]	infinite_dffe;
	reg	infinite_input_dffe;
	reg	[9:0]	intercept_dffe;
	reg	[51:0]	man_dffe_0;
	reg	[51:0]	man_dffe_1;
	reg	[51:0]	man_dffe_10;
	reg	[51:0]	man_dffe_11;
	reg	[51:0]	man_dffe_12;
	reg	[51:0]	man_dffe_13;
	reg	[51:0]	man_dffe_14;
	reg	[51:0]	man_dffe_15;
	reg	[51:0]	man_dffe_16;
	reg	[51:0]	man_dffe_17;
	reg	[51:0]	man_dffe_18;
	reg	[51:0]	man_dffe_2;
	reg	[51:0]	man_dffe_3;
	reg	[51:0]	man_dffe_4;
	reg	[51:0]	man_dffe_5;
	reg	[51:0]	man_dffe_6;
	reg	[51:0]	man_dffe_7;
	reg	[51:0]	man_dffe_8;
	reg	[51:0]	man_dffe_9;
	reg	[2:0]	nan_dffe;
	reg	nan_input_dffe;
	reg	nan_output_dffe;
	reg	[63:0]	result_output_dffe;
	reg	[25:0]	sign_dffe;
	reg	[2:0]	underflow_dffe;
	reg	underflow_output_dffe;
	reg	[12:0]	x_dffe_0;
	reg	[12:0]	x_dffe_1;
	reg	[53:0]	x_dffe_10;
	reg	[53:0]	x_dffe_11;
	reg	[12:0]	x_dffe_2;
	reg	[12:0]	x_dffe_3;
	reg	[36:0]	x_dffe_4;
	reg	[36:0]	x_dffe_5;
	reg	[36:0]	x_dffe_6;
	reg	[36:0]	x_dffe_7;
	reg	[53:0]	x_dffe_8;
	reg	[53:0]	x_dffe_9;
	reg	[2:0]	zero_dffe;
	reg	zero_input_dffe;
	reg	zero_output_dffe;
	wire  [6:0]   wire_approx_sub_result;
	wire  [11:0]   wire_bias_adjustment_result;
	wire  [12:0]   wire_modified_add_result;
	wire  wire_cmpr6_ageb;
	wire  [37:0]   wire_inner_mult0_result;
	wire  [76:0]   wire_inner_mult1_result;
	wire  [106:0]   wire_inner_mult2_result;
	wire  [37:0]   wire_outer_mult0_result;
	wire  [76:0]   wire_outer_mult1_result;
	wire  [107:0]   wire_outer_mult2_result;
	wire  [15:0]   wire_mux1_result;
	wire aclr;
	wire  [58:0]  and_b0_w;
	wire  [58:0]  and_b1_w;
	wire  [58:0]  and_b2_w;
	wire  [58:0]  and_b3_w;
	wire  [58:0]  and_b4_w;
	wire  [58:0]  and_b5_w;
	wire  [6:0]  approx_c_w;
	wire  [6:0]  approx_mx_w;
	wire  [12:0]  approx_y_w;
	wire  [12:0]  c_offset_w;
	wire  [54:0]  const_2_w;
	wire  [11:0]  const_bias_adj_greater_one_w;
	wire  [11:0]  const_bias_adj_one_w;
	wire  [11:0]  const_bias_adj_w;
	wire  [10:0]  data_exp_bus_w;
	wire  [51:0]  data_man_bus_w;
	wire  data_sign_w;
	wire  division_by_zero_out_w;
	wire  division_by_zero_w;
	wire  exp_and_msb_w;
	wire  [10:0]  exp_bus_w;
	wire  [10:0]  exp_exc_ones_w;
	wire  [10:0]  exp_exc_zeros_w;
	wire  exp_one_w;
	wire  exp_or_msb_w;
	wire  [10:0]  exp_res_w;
	wire  exp_zero_w;
	wire  gnd_w;
	wire  [63:0]  infi_res_w;
	wire  infinite_input_w;
	wire  infinite_out_w;
	wire  infinite_w;
	wire  man_and_msb_w;
	wire  [51:0]  man_bus_w;
	wire  [51:0]  man_exc_nan_w;
	wire  [51:0]  man_exc_zeros_w;
	wire  man_non_zero_w;
	wire  man_one_w;
	wire  man_or_msb_w;
	wire  [24:0]  man_out_0_w;
	wire  [39:0]  man_out_1_w;
	wire  [52:0]  man_out_2_w;
	wire  [51:0]  man_res_w;
	wire  man_zero_w;
	wire  [12:0]  modified_c_w;
	wire  [63:0]  mux_1_res_w;
	wire  [63:0]  mux_2_res_w;
	wire  [63:0]  mux_3_res_w;
	wire  nan_input_w;
	wire  nan_out_w;
	wire  [63:0]  nan_res_w;
	wire  nan_w;
	wire  [63:0]  norm_res_int_w;
	wire  [58:0]  shift_b0_w;
	wire  [58:0]  shift_b1_w;
	wire  [58:0]  shift_b2_w;
	wire  [58:0]  shift_b3_w;
	wire  [58:0]  shift_b4_w;
	wire  [58:0]  shift_b5_w;
	wire  sign_exc_bit_w;
	wire  sign_res_w;
	wire  [5:0]  slope_w;
	wire  [511:0]  table_bus_full_w;
	wire  underflow_out_w;
	wire  underflow_w;
	wire  vcc_w;
	wire  [12:0]  x_0_w;
	wire  [36:0]  x_1_w;
	wire  [53:0]  x_2_w;
	wire  [53:0]  x_3_w;
	wire  [12:0]  x_initial_w;
	wire  zero_input_w;
	wire  zero_out_w;
	wire  [63:0]  zero_res_w;
	wire  zero_w;

	Inverter_altfp_inv_and_or_ekd   altfp_inv_and_or2
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.data(man_bus_w),
	.result(wire_altfp_inv_and_or2_result));
	Inverter_altfp_inv_and_or_0nd   altfp_inv_and_or3
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.data(man_bus_w),
	.result(wire_altfp_inv_and_or3_result));
	Inverter_altfp_inv_and_or_9kd   altfp_inv_and_or4
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.data(exp_bus_w),
	.result(wire_altfp_inv_and_or4_result));
	Inverter_altfp_inv_and_or_rmd   altfp_inv_and_or5
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.data(exp_bus_w),
	.result(wire_altfp_inv_and_or5_result));
	Inverter_altfp_inv_csa_tbi   diff_adder_0
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.dataa(const_2_w[54:29]),
	.datab(wire_inner_mult0_result[37:12]),
	.result(wire_diff_adder_0_result));
	Inverter_altfp_inv_csa_qbi   diff_adder_1
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.dataa(const_2_w[54:14]),
	.datab(wire_inner_mult1_result[76:36]),
	.result(wire_diff_adder_1_result));
	Inverter_altfp_inv_csa_vbi   diff_adder_2
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.dataa(const_2_w[54:0]),
	.datab(wire_inner_mult2_result[106:52]),
	.result(wire_diff_adder_2_result));
	Inverter_altfp_inv_csa_47i   slope_r1c1_add
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.dataa(and_dffe_0),
	.datab(and_dffe_1),
	.result(wire_slope_r1c1_add_result));
	Inverter_altfp_inv_csa_47i   slope_r1c2_add
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.dataa(and_dffe_2),
	.datab(and_dffe_3),
	.result(wire_slope_r1c2_add_result));
	Inverter_altfp_inv_csa_47i   slope_r1c3_add
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.dataa(and_dffe_4),
	.datab(and_dffe_5),
	.result(wire_slope_r1c3_add_result));
	Inverter_altfp_inv_csa_47i   slope_r2c1_add
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.dataa(wire_slope_r1c1_add_result),
	.datab(wire_slope_r1c2_add_result),
	.result(wire_slope_r2c1_add_result));
	Inverter_altfp_inv_csa_58i   slope_r2c2_add
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.dataa(modified_c_w),
	.datab(wire_slope_r1c3_add_result),
	.result(wire_slope_r2c2_add_result));
	Inverter_altfp_inv_csa_58i   slope_r3c1_add
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.dataa(wire_slope_r2c2_add_result),
	.datab(wire_slope_r2c1_add_result),
	.result(wire_slope_r3c1_add_result));
	// synopsys translate_off
	initial
		and_dffe_0 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) and_dffe_0 <= 13'b0;
		else if  (clk_en == 1'b1)   and_dffe_0 <= and_b0_w[58:46];
	// synopsys translate_off
	initial
		and_dffe_1 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) and_dffe_1 <= 13'b0;
		else if  (clk_en == 1'b1)   and_dffe_1 <= and_b1_w[58:46];
	// synopsys translate_off
	initial
		and_dffe_2 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) and_dffe_2 <= 13'b0;
		else if  (clk_en == 1'b1)   and_dffe_2 <= and_b2_w[58:46];
	// synopsys translate_off
	initial
		and_dffe_3 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) and_dffe_3 <= 13'b0;
		else if  (clk_en == 1'b1)   and_dffe_3 <= and_b3_w[58:46];
	// synopsys translate_off
	initial
		and_dffe_4 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) and_dffe_4 <= 13'b0;
		else if  (clk_en == 1'b1)   and_dffe_4 <= and_b4_w[58:46];
	// synopsys translate_off
	initial
		and_dffe_5 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) and_dffe_5 <= 13'b0;
		else if  (clk_en == 1'b1)   and_dffe_5 <= and_b5_w[58:46];
	// synopsys translate_off
	initial
		division_by_zero_dffe = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) division_by_zero_dffe <= 3'b0;
		else if  (clk_en == 1'b1)   division_by_zero_dffe <= {division_by_zero_dffe[1:0], division_by_zero_w};
	// synopsys translate_off
	initial
		division_by_zero_output_dffe = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) division_by_zero_output_dffe <= 1'b0;
		else if  (clk_en == 1'b1)   division_by_zero_output_dffe <= division_by_zero_out_w;
	// synopsys translate_off
	initial
		exp_dffe1_0 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe1_0 <= 11'b0;
		else if  (clk_en == 1'b1)   exp_dffe1_0 <= data_exp_bus_w;
	// synopsys translate_off
	initial
		exp_dffe1_1 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe1_1 <= 11'b0;
		else if  (clk_en == 1'b1)   exp_dffe1_1 <= exp_dffe1_0;
	// synopsys translate_off
	initial
		exp_dffe1_10 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe1_10 <= 11'b0;
		else if  (clk_en == 1'b1)   exp_dffe1_10 <= exp_dffe1_9;
	// synopsys translate_off
	initial
		exp_dffe1_11 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe1_11 <= 11'b0;
		else if  (clk_en == 1'b1)   exp_dffe1_11 <= exp_dffe1_10;
	// synopsys translate_off
	initial
		exp_dffe1_12 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe1_12 <= 11'b0;
		else if  (clk_en == 1'b1)   exp_dffe1_12 <= exp_dffe1_11;
	// synopsys translate_off
	initial
		exp_dffe1_13 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe1_13 <= 11'b0;
		else if  (clk_en == 1'b1)   exp_dffe1_13 <= exp_dffe1_12;
	// synopsys translate_off
	initial
		exp_dffe1_14 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe1_14 <= 11'b0;
		else if  (clk_en == 1'b1)   exp_dffe1_14 <= exp_dffe1_13;
	// synopsys translate_off
	initial
		exp_dffe1_15 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe1_15 <= 11'b0;
		else if  (clk_en == 1'b1)   exp_dffe1_15 <= exp_dffe1_14;
	// synopsys translate_off
	initial
		exp_dffe1_16 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe1_16 <= 11'b0;
		else if  (clk_en == 1'b1)   exp_dffe1_16 <= exp_dffe1_15;
	// synopsys translate_off
	initial
		exp_dffe1_17 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe1_17 <= 11'b0;
		else if  (clk_en == 1'b1)   exp_dffe1_17 <= exp_dffe1_16;
	// synopsys translate_off
	initial
		exp_dffe1_18 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe1_18 <= 11'b0;
		else if  (clk_en == 1'b1)   exp_dffe1_18 <= exp_dffe1_17;
	// synopsys translate_off
	initial
		exp_dffe1_19 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe1_19 <= 11'b0;
		else if  (clk_en == 1'b1)   exp_dffe1_19 <= exp_dffe1_18;
	// synopsys translate_off
	initial
		exp_dffe1_2 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe1_2 <= 11'b0;
		else if  (clk_en == 1'b1)   exp_dffe1_2 <= exp_dffe1_1;
	// synopsys translate_off
	initial
		exp_dffe1_20 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe1_20 <= 11'b0;
		else if  (clk_en == 1'b1)   exp_dffe1_20 <= exp_dffe1_19;
	// synopsys translate_off
	initial
		exp_dffe1_21 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe1_21 <= 11'b0;
		else if  (clk_en == 1'b1)   exp_dffe1_21 <= exp_dffe1_20;
	// synopsys translate_off
	initial
		exp_dffe1_3 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe1_3 <= 11'b0;
		else if  (clk_en == 1'b1)   exp_dffe1_3 <= exp_dffe1_2;
	// synopsys translate_off
	initial
		exp_dffe1_4 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe1_4 <= 11'b0;
		else if  (clk_en == 1'b1)   exp_dffe1_4 <= exp_dffe1_3;
	// synopsys translate_off
	initial
		exp_dffe1_5 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe1_5 <= 11'b0;
		else if  (clk_en == 1'b1)   exp_dffe1_5 <= exp_dffe1_4;
	// synopsys translate_off
	initial
		exp_dffe1_6 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe1_6 <= 11'b0;
		else if  (clk_en == 1'b1)   exp_dffe1_6 <= exp_dffe1_5;
	// synopsys translate_off
	initial
		exp_dffe1_7 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe1_7 <= 11'b0;
		else if  (clk_en == 1'b1)   exp_dffe1_7 <= exp_dffe1_6;
	// synopsys translate_off
	initial
		exp_dffe1_8 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe1_8 <= 11'b0;
		else if  (clk_en == 1'b1)   exp_dffe1_8 <= exp_dffe1_7;
	// synopsys translate_off
	initial
		exp_dffe1_9 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe1_9 <= 11'b0;
		else if  (clk_en == 1'b1)   exp_dffe1_9 <= exp_dffe1_8;
	// synopsys translate_off
	initial
		exp_dffe2_0 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe2_0 <= 11'b0;
		else if  (clk_en == 1'b1)   exp_dffe2_0 <= wire_bias_adjustment_result[10:0];
	// synopsys translate_off
	initial
		exp_dffe2_1 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe2_1 <= 11'b0;
		else if  (clk_en == 1'b1)   exp_dffe2_1 <= exp_dffe2_0;
	// synopsys translate_off
	initial
		exp_dffe2_2 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe2_2 <= 11'b0;
		else if  (clk_en == 1'b1)   exp_dffe2_2 <= exp_dffe2_1;
	// synopsys translate_off
	initial
		infinite_dffe = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) infinite_dffe <= 3'b0;
		else if  (clk_en == 1'b1)   infinite_dffe <= {infinite_dffe[1:0], infinite_w};
	// synopsys translate_off
	initial
		infinite_input_dffe = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) infinite_input_dffe <= 1'b0;
		else if  (clk_en == 1'b1)   infinite_input_dffe <= (exp_one_w & man_zero_w);
	// synopsys translate_off
	initial
		intercept_dffe = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) intercept_dffe <= 10'b0;
		else if  (clk_en == 1'b1)   intercept_dffe <= wire_mux1_result[9:0];
	// synopsys translate_off
	initial
		man_dffe_0 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) man_dffe_0 <= 52'b0;
		else if  (clk_en == 1'b1)   man_dffe_0 <= data_man_bus_w;
	// synopsys translate_off
	initial
		man_dffe_1 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) man_dffe_1 <= 52'b0;
		else if  (clk_en == 1'b1)   man_dffe_1 <= man_dffe_0;
	// synopsys translate_off
	initial
		man_dffe_10 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) man_dffe_10 <= 52'b0;
		else if  (clk_en == 1'b1)   man_dffe_10 <= man_dffe_9;
	// synopsys translate_off
	initial
		man_dffe_11 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) man_dffe_11 <= 52'b0;
		else if  (clk_en == 1'b1)   man_dffe_11 <= man_dffe_10;
	// synopsys translate_off
	initial
		man_dffe_12 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) man_dffe_12 <= 52'b0;
		else if  (clk_en == 1'b1)   man_dffe_12 <= man_dffe_11;
	// synopsys translate_off
	initial
		man_dffe_13 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) man_dffe_13 <= 52'b0;
		else if  (clk_en == 1'b1)   man_dffe_13 <= man_dffe_12;
	// synopsys translate_off
	initial
		man_dffe_14 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) man_dffe_14 <= 52'b0;
		else if  (clk_en == 1'b1)   man_dffe_14 <= man_dffe_13;
	// synopsys translate_off
	initial
		man_dffe_15 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) man_dffe_15 <= 52'b0;
		else if  (clk_en == 1'b1)   man_dffe_15 <= man_dffe_14;
	// synopsys translate_off
	initial
		man_dffe_16 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) man_dffe_16 <= 52'b0;
		else if  (clk_en == 1'b1)   man_dffe_16 <= man_dffe_15;
	// synopsys translate_off
	initial
		man_dffe_17 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) man_dffe_17 <= 52'b0;
		else if  (clk_en == 1'b1)   man_dffe_17 <= man_dffe_16;
	// synopsys translate_off
	initial
		man_dffe_18 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) man_dffe_18 <= 52'b0;
		else if  (clk_en == 1'b1)   man_dffe_18 <= man_dffe_17;
	// synopsys translate_off
	initial
		man_dffe_2 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) man_dffe_2 <= 52'b0;
		else if  (clk_en == 1'b1)   man_dffe_2 <= man_dffe_1;
	// synopsys translate_off
	initial
		man_dffe_3 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) man_dffe_3 <= 52'b0;
		else if  (clk_en == 1'b1)   man_dffe_3 <= man_dffe_2;
	// synopsys translate_off
	initial
		man_dffe_4 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) man_dffe_4 <= 52'b0;
		else if  (clk_en == 1'b1)   man_dffe_4 <= man_dffe_3;
	// synopsys translate_off
	initial
		man_dffe_5 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) man_dffe_5 <= 52'b0;
		else if  (clk_en == 1'b1)   man_dffe_5 <= man_dffe_4;
	// synopsys translate_off
	initial
		man_dffe_6 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) man_dffe_6 <= 52'b0;
		else if  (clk_en == 1'b1)   man_dffe_6 <= man_dffe_5;
	// synopsys translate_off
	initial
		man_dffe_7 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) man_dffe_7 <= 52'b0;
		else if  (clk_en == 1'b1)   man_dffe_7 <= man_dffe_6;
	// synopsys translate_off
	initial
		man_dffe_8 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) man_dffe_8 <= 52'b0;
		else if  (clk_en == 1'b1)   man_dffe_8 <= man_dffe_7;
	// synopsys translate_off
	initial
		man_dffe_9 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) man_dffe_9 <= 52'b0;
		else if  (clk_en == 1'b1)   man_dffe_9 <= man_dffe_8;
	// synopsys translate_off
	initial
		nan_dffe = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) nan_dffe <= 3'b0;
		else if  (clk_en == 1'b1)   nan_dffe <= {nan_dffe[1:0], nan_w};
	// synopsys translate_off
	initial
		nan_input_dffe = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) nan_input_dffe <= 1'b0;
		else if  (clk_en == 1'b1)   nan_input_dffe <= (exp_one_w & (man_non_zero_w | man_one_w));
	// synopsys translate_off
	initial
		nan_output_dffe = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) nan_output_dffe <= 1'b0;
		else if  (clk_en == 1'b1)   nan_output_dffe <= nan_out_w;
	// synopsys translate_off
	initial
		result_output_dffe = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) result_output_dffe <= 64'b0;
		else if  (clk_en == 1'b1)   result_output_dffe <= mux_3_res_w;
	// synopsys translate_off
	initial
		sign_dffe = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) sign_dffe <= 26'b0;
		else if  (clk_en == 1'b1)   sign_dffe <= {sign_dffe[24:0], data_sign_w};
	// synopsys translate_off
	initial
		underflow_dffe = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) underflow_dffe <= 3'b0;
		else if  (clk_en == 1'b1)   underflow_dffe <= {underflow_dffe[1:0], underflow_w};
	// synopsys translate_off
	initial
		underflow_output_dffe = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) underflow_output_dffe <= 1'b0;
		else if  (clk_en == 1'b1)   underflow_output_dffe <= underflow_out_w;
	// synopsys translate_off
	initial
		x_dffe_0 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) x_dffe_0 <= 13'b0;
		else if  (clk_en == 1'b1)   x_dffe_0 <= x_0_w;
	// synopsys translate_off
	initial
		x_dffe_1 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) x_dffe_1 <= 13'b0;
		else if  (clk_en == 1'b1)   x_dffe_1 <= x_dffe_0;
	// synopsys translate_off
	initial
		x_dffe_10 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) x_dffe_10 <= 54'b0;
		else if  (clk_en == 1'b1)   x_dffe_10 <= x_dffe_9;
	// synopsys translate_off
	initial
		x_dffe_11 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) x_dffe_11 <= 54'b0;
		else if  (clk_en == 1'b1)   x_dffe_11 <= x_dffe_10;
	// synopsys translate_off
	initial
		x_dffe_2 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) x_dffe_2 <= 13'b0;
		else if  (clk_en == 1'b1)   x_dffe_2 <= x_dffe_1;
	// synopsys translate_off
	initial
		x_dffe_3 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) x_dffe_3 <= 13'b0;
		else if  (clk_en == 1'b1)   x_dffe_3 <= x_dffe_2;
	// synopsys translate_off
	initial
		x_dffe_4 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) x_dffe_4 <= 37'b0;
		else if  (clk_en == 1'b1)   x_dffe_4 <= x_1_w;
	// synopsys translate_off
	initial
		x_dffe_5 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) x_dffe_5 <= 37'b0;
		else if  (clk_en == 1'b1)   x_dffe_5 <= x_dffe_4;
	// synopsys translate_off
	initial
		x_dffe_6 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) x_dffe_6 <= 37'b0;
		else if  (clk_en == 1'b1)   x_dffe_6 <= x_dffe_5;
	// synopsys translate_off
	initial
		x_dffe_7 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) x_dffe_7 <= 37'b0;
		else if  (clk_en == 1'b1)   x_dffe_7 <= x_dffe_6;
	// synopsys translate_off
	initial
		x_dffe_8 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) x_dffe_8 <= 54'b0;
		else if  (clk_en == 1'b1)   x_dffe_8 <= x_2_w;
	// synopsys translate_off
	initial
		x_dffe_9 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) x_dffe_9 <= 54'b0;
		else if  (clk_en == 1'b1)   x_dffe_9 <= x_dffe_8;
	// synopsys translate_off
	initial
		zero_dffe = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) zero_dffe <= 3'b0;
		else if  (clk_en == 1'b1)   zero_dffe <= {zero_dffe[1:0], zero_w};
	// synopsys translate_off
	initial
		zero_input_dffe = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) zero_input_dffe <= 1'b0;
		else if  (clk_en == 1'b1)   zero_input_dffe <= (exp_zero_w & ((man_one_w | man_non_zero_w) | man_zero_w));
	// synopsys translate_off
	initial
		zero_output_dffe = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) zero_output_dffe <= 1'b0;
		else if  (clk_en == 1'b1)   zero_output_dffe <= zero_out_w;
	lpm_add_sub   approx_sub
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.cout(),
	.dataa(approx_c_w),
	.datab(approx_mx_w),
	.overflow(),
	.result(wire_approx_sub_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.add_sub(1'b1),
	.cin()
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		approx_sub.lpm_direction = "SUB",
		approx_sub.lpm_pipeline = 1,
		approx_sub.lpm_representation = "UNSIGNED",
		approx_sub.lpm_width = 7,
		approx_sub.lpm_type = "lpm_add_sub";
	lpm_add_sub   bias_adjustment
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.cout(),
	.dataa(const_bias_adj_w),
	.datab({gnd_w, exp_dffe1_21}),
	.overflow(),
	.result(wire_bias_adjustment_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.add_sub(1'b1),
	.cin()
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		bias_adjustment.lpm_direction = "SUB",
		bias_adjustment.lpm_pipeline = 1,
		bias_adjustment.lpm_representation = "UNSIGNED",
		bias_adjustment.lpm_width = 12,
		bias_adjustment.lpm_type = "lpm_add_sub",
		bias_adjustment.lpm_hint = "ONE_INPUT_IS_CONSTANT=YES";
	lpm_add_sub   modified_add
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.cout(),
	.dataa(approx_y_w),
	.datab(c_offset_w),
	.overflow(),
	.result(wire_modified_add_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.add_sub(1'b1),
	.cin()
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		modified_add.lpm_direction = "SUB",
		modified_add.lpm_pipeline = 1,
		modified_add.lpm_representation = "UNSIGNED",
		modified_add.lpm_width = 13,
		modified_add.lpm_type = "lpm_add_sub";
	lpm_compare   cmpr6
	( 
	.aclr(aclr),
	.aeb(),
	.agb(),
	.ageb(wire_cmpr6_ageb),
	.alb(),
	.aleb(),
	.aneb(),
	.clken(clk_en),
	.clock(clock),
	.dataa({gnd_w, exp_dffe1_21}),
	.datab(const_bias_adj_w));
	defparam
		cmpr6.lpm_pipeline = 1,
		cmpr6.lpm_representation = "UNSIGNED",
		cmpr6.lpm_width = 12,
		cmpr6.lpm_type = "lpm_compare";
	lpm_mult   inner_mult0
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.dataa(man_out_0_w),
	.datab(x_0_w),
	.result(wire_inner_mult0_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.sclr(1'b0),
	.sum({1{1'b0}})
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		inner_mult0.lpm_pipeline = 3,
		inner_mult0.lpm_representation = "UNSIGNED",
		inner_mult0.lpm_widtha = 25,
		inner_mult0.lpm_widthb = 13,
		inner_mult0.lpm_widthp = 38,
		inner_mult0.lpm_type = "lpm_mult",
		inner_mult0.lpm_hint = "DEDICATED_MULTIPLIER_CIRCUITRY=AUTO";
	lpm_mult   inner_mult1
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.dataa(man_out_1_w),
	.datab(x_1_w),
	.result(wire_inner_mult1_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.sclr(1'b0),
	.sum({1{1'b0}})
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		inner_mult1.lpm_pipeline = 3,
		inner_mult1.lpm_representation = "UNSIGNED",
		inner_mult1.lpm_widtha = 40,
		inner_mult1.lpm_widthb = 37,
		inner_mult1.lpm_widthp = 77,
		inner_mult1.lpm_type = "lpm_mult",
		inner_mult1.lpm_hint = "DEDICATED_MULTIPLIER_CIRCUITRY=AUTO";
	lpm_mult   inner_mult2
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.dataa(man_out_2_w),
	.datab(x_2_w),
	.result(wire_inner_mult2_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.sclr(1'b0),
	.sum({1{1'b0}})
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		inner_mult2.lpm_pipeline = 3,
		inner_mult2.lpm_representation = "UNSIGNED",
		inner_mult2.lpm_widtha = 53,
		inner_mult2.lpm_widthb = 54,
		inner_mult2.lpm_widthp = 107,
		inner_mult2.lpm_type = "lpm_mult",
		inner_mult2.lpm_hint = "DEDICATED_MULTIPLIER_CIRCUITRY=AUTO";
	lpm_mult   outer_mult0
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.dataa(wire_diff_adder_0_result[24:0]),
	.datab(x_dffe_3),
	.result(wire_outer_mult0_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.sclr(1'b0),
	.sum({1{1'b0}})
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		outer_mult0.lpm_pipeline = 3,
		outer_mult0.lpm_representation = "UNSIGNED",
		outer_mult0.lpm_widtha = 25,
		outer_mult0.lpm_widthb = 13,
		outer_mult0.lpm_widthp = 38,
		outer_mult0.lpm_type = "lpm_mult",
		outer_mult0.lpm_hint = "DEDICATED_MULTIPLIER_CIRCUITRY=AUTO";
	lpm_mult   outer_mult1
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.dataa(wire_diff_adder_1_result[39:0]),
	.datab(x_dffe_7),
	.result(wire_outer_mult1_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.sclr(1'b0),
	.sum({1{1'b0}})
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		outer_mult1.lpm_pipeline = 3,
		outer_mult1.lpm_representation = "UNSIGNED",
		outer_mult1.lpm_widtha = 40,
		outer_mult1.lpm_widthb = 37,
		outer_mult1.lpm_widthp = 77,
		outer_mult1.lpm_type = "lpm_mult",
		outer_mult1.lpm_hint = "DEDICATED_MULTIPLIER_CIRCUITRY=AUTO";
	lpm_mult   outer_mult2
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.dataa(wire_diff_adder_2_result[53:0]),
	.datab(x_dffe_11),
	.result(wire_outer_mult2_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.sclr(1'b0),
	.sum({1{1'b0}})
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		outer_mult2.lpm_pipeline = 3,
		outer_mult2.lpm_representation = "UNSIGNED",
		outer_mult2.lpm_widtha = 54,
		outer_mult2.lpm_widthb = 54,
		outer_mult2.lpm_widthp = 108,
		outer_mult2.lpm_type = "lpm_mult",
		outer_mult2.lpm_hint = "DEDICATED_MULTIPLIER_CIRCUITRY=AUTO";
	lpm_mux   mux1
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.data(table_bus_full_w),
	.result(wire_mux1_result),
	.sel(data_man_bus_w[51:47]));
	defparam
		mux1.lpm_pipeline = 1,
		mux1.lpm_size = 32,
		mux1.lpm_width = 16,
		mux1.lpm_widths = 5,
		mux1.lpm_type = "lpm_mux";
	assign
		aclr = 1'b0,
		and_b0_w = ({59{slope_w[5]}} & shift_b0_w),
		and_b1_w = ({59{slope_w[4]}} & shift_b1_w),
		and_b2_w = ({59{slope_w[3]}} & shift_b2_w),
		and_b3_w = ({59{slope_w[2]}} & shift_b3_w),
		and_b4_w = ({59{slope_w[1]}} & shift_b4_w),
		and_b5_w = ({59{slope_w[0]}} & shift_b5_w),
		approx_c_w = 7'b1100000,
		approx_mx_w = {gnd_w, vcc_w, man_dffe_0[51:47]},
		approx_y_w = {wire_approx_sub_result[5:0], {7{gnd_w}}},
		c_offset_w = {{3{gnd_w}}, intercept_dffe},
		const_2_w = 55'b1000000000000000000000000000000000000000000000000000000,
		const_bias_adj_greater_one_w = 12'b011111111101,
		const_bias_adj_one_w = 12'b011111111110,
		const_bias_adj_w = (({12{(~ man_zero_w)}} & const_bias_adj_greater_one_w) | ({12{man_zero_w}} & const_bias_adj_one_w)),
		data_exp_bus_w = data[62:52],
		data_man_bus_w = data[51:0],
		data_sign_w = data[63],
		division_by_zero = division_by_zero_output_dffe,
		division_by_zero_out_w = division_by_zero_dffe[2],
		division_by_zero_w = zero_input_w,
		exp_and_msb_w = wire_altfp_inv_and_or5_result,
		exp_bus_w = exp_dffe1_18,
		exp_exc_ones_w = {11{1'b1}},
		exp_exc_zeros_w = {11{1'b0}},
		exp_one_w = exp_and_msb_w,
		exp_or_msb_w = wire_altfp_inv_and_or4_result,
		exp_res_w = exp_dffe2_2,
		exp_zero_w = (~ exp_or_msb_w),
		gnd_w = 1'b0,
		infi_res_w = {sign_exc_bit_w, exp_exc_ones_w, man_exc_zeros_w},
		infinite_input_w = infinite_input_dffe,
		infinite_out_w = infinite_dffe[2],
		infinite_w = zero_input_w,
		man_and_msb_w = wire_altfp_inv_and_or3_result,
		man_bus_w = man_dffe_18,
		man_exc_nan_w = {vcc_w, man_exc_zeros_w[50:0]},
		man_exc_zeros_w = {52{1'b0}},
		man_non_zero_w = man_or_msb_w,
		man_one_w = man_and_msb_w,
		man_or_msb_w = wire_altfp_inv_and_or2_result,
		man_out_0_w = {vcc_w, man_dffe_4[51:28]},
		man_out_1_w = {vcc_w, man_dffe_11[51:13]},
		man_out_2_w = {vcc_w, man_dffe_18[51:0]},
		man_res_w = x_3_w[51:0],
		man_zero_w = (~ man_or_msb_w),
		modified_c_w = wire_modified_add_result[12:0],
		mux_1_res_w = (({64{infinite_out_w}} & infi_res_w) | ({64{(~ infinite_out_w)}} & norm_res_int_w)),
		mux_2_res_w = (({64{zero_out_w}} & zero_res_w) | ({64{(~ zero_out_w)}} & mux_1_res_w)),
		mux_3_res_w = (({64{nan_out_w}} & nan_res_w) | ({64{(~ nan_out_w)}} & mux_2_res_w)),
		nan = nan_output_dffe,
		nan_input_w = nan_input_dffe,
		nan_out_w = nan_dffe[2],
		nan_res_w = {sign_exc_bit_w, exp_exc_ones_w, man_exc_nan_w},
		nan_w = nan_input_w,
		norm_res_int_w = {sign_res_w, exp_res_w, man_res_w},
		result = result_output_dffe,
		shift_b0_w = {gnd_w, vcc_w, man_dffe_0, {5{gnd_w}}},
		shift_b1_w = {{2{gnd_w}}, vcc_w, man_dffe_0, {4{gnd_w}}},
		shift_b2_w = {{3{gnd_w}}, vcc_w, man_dffe_0, {3{gnd_w}}},
		shift_b3_w = {{4{gnd_w}}, vcc_w, man_dffe_0, {2{gnd_w}}},
		shift_b4_w = {{5{gnd_w}}, vcc_w, man_dffe_0, gnd_w},
		shift_b5_w = {{6{gnd_w}}, vcc_w, man_dffe_0},
		sign_exc_bit_w = sign_res_w,
		sign_res_w = sign_dffe[25],
		slope_w = wire_mux1_result[15:10],
		table_bus_full_w = {16'b0100010000000001, 16'b0100010010000001, 16'b0100100010000111, 16'b0100100100000111, 16'b0100110100010000, 16'b0101000100011100, 16'b0101000110011100, 16'b0101010110101011, 16'b0101100110111100, 16'b0101110111010000, 16'b0101111001010001, 16'b0110001001100111, 16'b0110011001111111, 16'b0110101010011010, 16'b0110111010110111, 16'b0111001011010101, 16'b0111101010010111, 16'b0111111010111010, 16'b1000001011011111, 16'b1000101010101101, 16'b1000111011010101, 16'b1001011010101011, 16'b1001111010000101, 16'b1010001010110011, 16'b1010111001000101, 16'b1011011000101010, 16'b1011111000010011, 16'b1100100110110111, 16'b1101010101100001, 16'b1110000100010001, 16'b1110110011000110, 16'b1111110001000000},
		underflow = underflow_output_dffe,
		underflow_out_w = underflow_dffe[2],
		underflow_w = (((~ infinite_input_w) & (~ nan_input_w)) & wire_cmpr6_ageb),
		vcc_w = 1'b1,
		x_0_w = x_initial_w,
		x_1_w = wire_outer_mult0_result[36:0],
		x_2_w = wire_outer_mult1_result[75:22],
		x_3_w = wire_outer_mult2_result[106:53],
		x_initial_w = wire_slope_r3c1_add_result,
		zero = zero_output_dffe,
		zero_input_w = zero_input_dffe,
		zero_out_w = zero_dffe[2],
		zero_res_w = {sign_exc_bit_w, exp_exc_zeros_w, man_exc_zeros_w},
		zero_w = ((~ nan_input_w) & (infinite_input_w | underflow_w));
endmodule //Inverter_altfp_inv_flg
//VALID FILE


// synopsys translate_off
`timescale 1 ps / 1 ps
// synopsys translate_on
module Inverter (
	clk_en,
	clock,
	data,
	division_by_zero,
	nan,
	result,
	underflow,
	zero);

	input	  clk_en;
	input	  clock;
	input	[63:0]  data;
	output	  division_by_zero;
	output	  nan;
	output	[63:0]  result;
	output	  underflow;
	output	  zero;

	wire  sub_wire0;
	wire  sub_wire1;
	wire [63:0] sub_wire2;
	wire  sub_wire3;
	wire  sub_wire4;
	wire  division_by_zero = sub_wire0;
	wire  nan = sub_wire1;
	wire [63:0] result = sub_wire2[63:0];
	wire  underflow = sub_wire3;
	wire  zero = sub_wire4;

	Inverter_altfp_inv_flg	Inverter_altfp_inv_flg_component (
				.clk_en (clk_en),
				.clock (clock),
				.data (data),
				.division_by_zero (sub_wire0),
				.nan (sub_wire1),
				.result (sub_wire2),
				.underflow (sub_wire3),
				.zero (sub_wire4));

endmodule

// ============================================================
// CNX file retrieval info
// ============================================================
// Retrieval info: LIBRARY: altera_mf altera_mf.altera_mf_components.all
// Retrieval info: PRIVATE: INTENDED_DEVICE_FAMILY STRING "Cyclone V"
// Retrieval info: CONSTANT: INTENDED_DEVICE_FAMILY STRING "UNUSED"
// Retrieval info: CONSTANT: LPM_HINT STRING "UNUSED"
// Retrieval info: CONSTANT: LPM_TYPE STRING "altfp_inv"
// Retrieval info: CONSTANT: PIPELINE NUMERIC "27"
// Retrieval info: CONSTANT: ROUNDING STRING "TO_NEAREST"
// Retrieval info: CONSTANT: WIDTH_EXP NUMERIC "11"
// Retrieval info: CONSTANT: WIDTH_MAN NUMERIC "52"
// Retrieval info: USED_PORT: clk_en 0 0 0 0 INPUT NODEFVAL "clk_en"
// Retrieval info: CONNECT: @clk_en 0 0 0 0 clk_en 0 0 0 0
// Retrieval info: USED_PORT: clock 0 0 0 0 INPUT NODEFVAL "clock"
// Retrieval info: CONNECT: @clock 0 0 0 0 clock 0 0 0 0
// Retrieval info: USED_PORT: data 0 0 64 0 INPUT NODEFVAL "data[63..0]"
// Retrieval info: CONNECT: @data 0 0 64 0 data 0 0 64 0
// Retrieval info: USED_PORT: division_by_zero 0 0 0 0 OUTPUT NODEFVAL "division_by_zero"
// Retrieval info: CONNECT: division_by_zero 0 0 0 0 @division_by_zero 0 0 0 0
// Retrieval info: USED_PORT: nan 0 0 0 0 OUTPUT NODEFVAL "nan"
// Retrieval info: CONNECT: nan 0 0 0 0 @nan 0 0 0 0
// Retrieval info: USED_PORT: result 0 0 64 0 OUTPUT NODEFVAL "result[63..0]"
// Retrieval info: CONNECT: result 0 0 64 0 @result 0 0 64 0
// Retrieval info: USED_PORT: underflow 0 0 0 0 OUTPUT NODEFVAL "underflow"
// Retrieval info: CONNECT: underflow 0 0 0 0 @underflow 0 0 0 0
// Retrieval info: USED_PORT: zero 0 0 0 0 OUTPUT NODEFVAL "zero"
// Retrieval info: CONNECT: zero 0 0 0 0 @zero 0 0 0 0
// Retrieval info: GEN_FILE: TYPE_NORMAL Inverter.v TRUE FALSE
// Retrieval info: GEN_FILE: TYPE_NORMAL Inverter.qip TRUE FALSE
// Retrieval info: GEN_FILE: TYPE_NORMAL Inverter.bsf FALSE TRUE
// Retrieval info: GEN_FILE: TYPE_NORMAL Inverter_inst.v TRUE TRUE
// Retrieval info: GEN_FILE: TYPE_NORMAL Inverter_bb.v TRUE TRUE
// Retrieval info: GEN_FILE: TYPE_NORMAL Inverter.inc FALSE TRUE
// Retrieval info: GEN_FILE: TYPE_NORMAL Inverter.cmp FALSE TRUE
// Retrieval info: LIB_FILE: lpm
